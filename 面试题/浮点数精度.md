# 浮点数精度问题

首先说这三个点

- 非是 ECMAScript 独有
- IEEE754 标准中 64 位的储存格式，比如 11 位存偏移值
- 其中涉及的三次精度丢失

然后描述一下原理，再讲解决方案

```js
// 比较
function DeviationValue(num1, num2) {
    return Math.abs(num1 - num2) < Number.EPSILON
}

function strip(num, precision = 12) {
  return +parseFloat(num.toPrecision(precision));
}

// 对于运算类操作，如 +-*/，就不能使用 toPrecision 了。正确的做法是把小数转成整数后再运算。以加法为例：
function add(num1, num2) {
  const num1Digits = (num1.toString().split('.')[1] || '').length;
  const num2Digits = (num2.toString().split('.')[1] || '').length;
  const baseNum = Math.pow(10, Math.max(num1Digits, num2Digits));
  return (num1 * baseNum + num2 * baseNum) / baseNum;
}

```

对要求比较高的也可以使用库

[number-precision](https://github.com/nefe/number-precision)
[math.js](https://github.com/josdejong/mathjs)


## 推荐阅读文章

- [传送门1](https://github.com/camsong/blog/issues/9) **必读**
- [传送门2](https://github.com/mqyqingfeng/Blog/issues/155)