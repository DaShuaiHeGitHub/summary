<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Document</title>
</head>
<body>
    <script>
        // map 用来记录被复制过的值
        const deepClone = (target, map = new WeakMap()) => {
            // null undefined 直接返回
            if(target == null) return target
            if(target instanceof Date) return new Date(target)

            if(target instanceof RegExp) return new RegExp(target)

            // number string boolean function 直接返回
            if(typeof target !== 'object') return target

            // 判断是否被复制过，避免循环引用
            const exist = map.get(target)
            if(exist) return exist // 如果已经存在，即被复制过就直接返回

            // 对象和数组
            // const res = Array.isArray(target) ? [] : {}
            const res = new target.constructor()

            map.set(target, res)

            for (const key in target) {
                if (Object.hasOwnProperty.call(target, key)) {
                    res[key] = deepClone(target[key], map)
                }
            }

            return res
        }

        const source = {
            string: 'string',
            boolean: true,
            null: null,
            undefined: undefined,
            number: 3.1,
            date: new Date(),
            reg: /\d+/,
            fn: console.log,
            arr: [1, 3, 5],
            man: {
                age: 25,
                name: 'he',
            }
        }
        const copy = deepClone(source)




        const connect = (...args) => args.toString()
        const length = v => v.length
        const prefix = v => '$' + v

        // 基础思路
        // const compose = (...fns) => {
        //     return function(...args) {
        //         const lastFn = fns.pop()
        //         const prev = lastFn(...args)
                
        //         return fns.reduceRight(function(prev, current) {
        //             return current(prev)
        //         }, prev)
        //     }
        // }

        // redux 思路
        const compose = (...fns) => {
            return fns.reduce(function(prev, current) {
                return function(...args) {
                    return prev(current(...args))
                }
            })
        }

        const res = compose(prefix, length, connect)
        // const res = compose(length, connect)
        console.log(res('a', 'b', 'c'))

    </script>    
</body>
</html>